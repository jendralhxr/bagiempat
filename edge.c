#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/time.h>
#include <mpi.h>
#include <math.h>

// generated by gui apps
#define PARTITION_WIDTH 4
#define PARTITION_HEIGHT 4
#define NUM_WIDTH 2
#define NUM_HEIGHT 2
#define BOUNDARY_LEFT 10
#define BOUNDARY_RIGHT -10
#define BOUNDARY_TOP 30
#define BOUNDARY_BOTTOM 200
#define ERROR_MARGIN 1e-9
#define STEP_MAX 1e6

double **element_local, **element_global, temp; // the whole array, kept at node_rank==0
double *buffer_recv_top, *buffer_recv_bottom, *buffer_recv_left, *buffer_recv_right;
double *buffer_send_top, *buffer_send_bottom, *buffer_send_left, *buffer_send_right;
unsigned int step=0, divergence_local=1, divergence_global=1;
int node_count, node_rank, node_namelen;
char node_name[MPI_MAX_PROCESSOR_NAME];
struct timeval start_time, stop_time;
struct timeval process_start_time, process_stop_time;
struct timeval aggregate_start_time, aggregate_stop_time;
double total_processing_time, total_aggregation_time; // sec
char side_flag[4]; // 0, 1, 2, 3: left, top, right, bot
int i, j, k, i_min, i_max, j_min, j_max;
MPI_Status status;

int main(int argc, char *argv[]){
	buffer_recv_top = malloc(sizeof(double)*(PARTITION_WIDTH+2));
	buffer_recv_bottom = malloc(sizeof(double)*(PARTITION_WIDTH+2));
	buffer_recv_left = malloc(sizeof(double)*(PARTITION_HEIGHT+2));
	buffer_recv_right = malloc(sizeof(double)*(PARTITION_HEIGHT+2));
	buffer_send_top = malloc(sizeof(double)*(PARTITION_WIDTH+2));
	buffer_send_bottom = malloc(sizeof(double)*(PARTITION_WIDTH+2));
	buffer_send_left = malloc(sizeof(double)*(PARTITION_HEIGHT+2));
	buffer_send_right = malloc(sizeof(double)*(PARTITION_HEIGHT+2));
	
	element_local = malloc(sizeof(double*)*(PARTITION_HEIGHT+2));
	for (i=0; i<PARTITION_HEIGHT; i++){
		element_local[i] = malloc(sizeof(double)*(PARTITION_WIDTH+2));
		}
	
	element_global = malloc(sizeof(double*)*(PARTITION_HEIGHT*NUM_HEIGHT+2));
	for (i=0; i<PARTITION_HEIGHT*NUM_HEIGHT; i++){
		element_global[i] = malloc(sizeof(double)*(PARTITION_WIDTH*NUM_WIDTH+2));
		}
	
	// assigning boundary values to global 
	for (i=1; i<=PARTITION_HEIGHT*NUM_HEIGHT; i++){
		element_global[i][1] = BOUNDARY_LEFT;
		element_global[i][PARTITION_WIDTH*NUM_WIDTH] = BOUNDARY_RIGHT;
		}
	for (i=1; i<=PARTITION_WIDTH*NUM_WIDTH; i++){
		element_global[1][i] = BOUNDARY_TOP;
		element_global[PARTITION_HEIGHT*NUM_HEIGHT][i] = BOUNDARY_BOTTOM;
		}
	
	MPI_Init(&argc, &argv);
	MPI_Comm_size(MPI_COMM_WORLD, &node_count);
	MPI_Comm_rank(MPI_COMM_WORLD, &node_rank);
	MPI_Get_processor_name(node_name, &node_namelen);

	// 0: don't mess; 1: you may do so
	side_flag[0]=(node_rank%NUM_WIDTH==0)?0:1;
	side_flag[1]=(node_rank<NUM_WIDTH)?0:1;
	side_flag[2]=(node_rank%NUM_WIDTH==NUM_WIDTH-1)?0:1;
	side_flag[3]=(node_rank>=NUM_WIDTH*(NUM_HEIGHT-1))?0:1;

	// local assigment is necessary here
	// assign left boundary
	if (node_rank%NUM_WIDTH==0){
		for (j=0; j<PARTITION_HEIGHT+2; j++){
			element_local[j][1]= BOUNDARY_LEFT;	
			}
		}
	// assign top boundary
	if (node_rank<NUM_WIDTH){
		for (i=0; i<PARTITION_WIDTH+2; i++){
			element_local[1][i]= BOUNDARY_TOP;
			}
		}
	// assign right boundary
	if (node_rank%NUM_WIDTH==NUM_WIDTH-1){
		for (j=0; j<PARTITION_HEIGHT+2; j++){
			element_local[j][PARTITION_WIDTH]= BOUNDARY_RIGHT;	
			}
		}
	// assign bot boundary
	if (node_rank>=NUM_WIDTH*(NUM_HEIGHT-1)){
		for (i=0; i<PARTITION_WIDTH+2; i++){
			element_local[PARTITION_HEIGHT][i]= BOUNDARY_BOTTOM;
			}
		}
	
// start
if (!node_rank){
	gettimeofday(&start_time,NULL);
	//printf("bagiempat: start = %d.%d\n",start_time.tv_sec,start_time.tv_usec);
	}

// do the actual work here
while(divergence_global && (step<STEP_MAX)){
	step++;
	divergence_global=0;
	// assigment to element_local from master node	
	for (k=0; k<node_count; k++){
		if (node_rank==0){
			// here lies the assignment
			// each worker get's its neighboring edges
			// assign left edge
			if (!(k%NUM_WIDTH==0)){
				for (j=0; j<PARTITION_HEIGHT+2; j++){
					buffer_send_left[j]= element_global[k/NUM_WIDTH*PARTITION_HEIGHT+j][k%NUM_WIDTH*PARTITION_WIDTH];
					}
				}
			// assign top edge
			if (!(k<NUM_WIDTH)){
				memcpy(buffer_send_top,&(element_global[k/NUM_WIDTH*PARTITION_HEIGHT][k%NUM_WIDTH*PARTITION_WIDTH]),sizeof(double)*(PARTITION_WIDTH+2));
				}
			// assign right edge
			if (!(k%NUM_WIDTH==NUM_WIDTH-1)){
				for (j=0; j<PARTITION_HEIGHT+2; j++){
					buffer_send_right[j]= element_global[k/NUM_WIDTH*PARTITION_HEIGHT+j][(k%NUM_WIDTH+1)*PARTITION_WIDTH];
					}
				}
			// assign bot edge
			if (!(k>=NUM_WIDTH*(NUM_HEIGHT-1))){
				memcpy(buffer_send_bottom,&(element_global[(k/NUM_WIDTH+1)*PARTITION_HEIGHT+1][k%NUM_WIDTH*PARTITION_WIDTH]),sizeof(double)*(PARTITION_WIDTH+2));
				}
			
			// send all 4 sides, tag is a*10 + side_id
			// left
			if (!(k%NUM_WIDTH==0)) MPI_Send(buffer_send_left,PARTITION_HEIGHT+2,MPI_DOUBLE,k,100*k+0,MPI_COMM_WORLD);
			// top
			if (!(k<NUM_WIDTH)) MPI_Send(buffer_send_top,PARTITION_WIDTH+2,MPI_DOUBLE,k,100*k+1,MPI_COMM_WORLD);
			// right
			if (!(k%NUM_WIDTH==NUM_WIDTH-1)) MPI_Send(buffer_send_right,PARTITION_HEIGHT+2,MPI_DOUBLE,k,100*k+2,MPI_COMM_WORLD);
			// bottom
			if (!(k>=NUM_WIDTH*(NUM_HEIGHT-1))) MPI_Send(buffer_send_bottom,PARTITION_WIDTH+2,MPI_DOUBLE,k,100*k+3,MPI_COMM_WORLD);
			}
			
		// assign receive buffer to local elements
		if (node_rank==k){
			if (side_flag[0]){
				MPI_Recv(buffer_recv_left,PARTITION_HEIGHT+2,MPI_DOUBLE,0,100*k+0,MPI_COMM_WORLD,&status);
				for (j=0; j<PARTITION_HEIGHT+2; j++){
					element_local[j][0]= buffer_recv_left[j];
					}
				}
			if (side_flag[1]){
				MPI_Recv(buffer_recv_top,PARTITION_WIDTH+2,MPI_DOUBLE,0,100*k+1,MPI_COMM_WORLD,&status);
				memcpy(&(element_local[0][0]),buffer_recv_top,sizeof(double)*PARTITION_WIDTH+2);
				} 
			if (side_flag[2]){
				MPI_Recv(buffer_recv_right,PARTITION_HEIGHT,MPI_DOUBLE,0,100*k+2,MPI_COMM_WORLD,&status);
				for (j=0; j<PARTITION_HEIGHT+2; j++){
					element_local[j][PARTITION_WIDTH+1]= buffer_recv_right[j];
					}
				} 
			if (side_flag[3]){
				MPI_Recv(buffer_recv_bottom,PARTITION_HEIGHT,MPI_DOUBLE,0,100*k+3,MPI_COMM_WORLD,&status);
				memcpy(&(element_local[PARTITION_WIDTH+1][0]),buffer_recv_bottom,sizeof(double)*PARTITION_WIDTH+2);
				} 
			}
		}
					
	// processing boundary check
	// top-left corner
	if (node_rank==0){
		j_min=2; j_max=PARTITION_HEIGHT;
		i_min=2; i_max=PARTITION_WIDTH;
		}
	// top-right corner
	else if (node_rank==NUM_WIDTH-1){
		j_min=2; j_max=PARTITION_HEIGHT;
		i_min=1; i_max=PARTITION_WIDTH-1;
		}
	// bottom-left corner
	else if (node_rank==NUM_HEIGHT*NUM_WIDTH-NUM_WIDTH){
		j_min=1; j_max=PARTITION_HEIGHT-1;
		i_min=2; i_max=PARTITION_WIDTH;
		}
	// bottom-right corner
	else if (node_rank==NUM_HEIGHT*NUM_WIDTH-1){
		j_min=1; j_max=PARTITION_HEIGHT-1;
		i_min=1; i_max=PARTITION_WIDTH-1;
		}
	// top edges
	else if (node_rank<NUM_WIDTH){
		j_min=2; j_max=PARTITION_HEIGHT;
		i_min=1; i_max=PARTITION_WIDTH;
		}
	// bottom edges
	else if (node_rank>=NUM_WIDTH*(NUM_HEIGHT-1)){
		j_min=1; j_max=PARTITION_HEIGHT-1;
		i_min=1; i_max=PARTITION_WIDTH;
		}
	// left edges
	else if (node_rank%NUM_WIDTH==0){
		j_min=1; j_max=PARTITION_HEIGHT;
		i_min=2; i_max=PARTITION_WIDTH;
		}
	// right edges
	else if (node_rank%NUM_WIDTH==NUM_WIDTH-1){
		j_min=1; j_max=PARTITION_HEIGHT;
		i_min=1; i_max=PARTITION_WIDTH-1;
		}
	// middle partitions
	else{
		j_min=1; j_max=PARTITION_HEIGHT;
		i_min=1; i_max=PARTITION_WIDTH;
		}

	// computing element_local: 4-way mean for elements within each partition
	// divergence check
	gettimeofday(&process_start_time,NULL);	
	divergence_local=0;
	for (j=j_min; j<=j_max; j++){
		for (i=i_min; i<=i_max; i++){
			temp = 0.25*(element_local[j-1][i]+element_local[j+1][i]+\
						 element_local[j][i-1]+element_local[j][i+1]);
			if (fabs(element_local[j][i]-temp)>ERROR_MARGIN){
				divergence_local=1;
				element_local[j][i]=temp;
				}
			}
		}
	gettimeofday(&process_stop_time,NULL);	
	total_processing_time += (process_stop_time.tv_sec-process_start_time.tv_sec+\
		(double)(process_stop_time.tv_usec-process_start_time.tv_usec)/1000000);
	
		
	// update to element_global
	for (k=0; k<node_count; k++){
		// summing divergence values
		MPI_Reduce(&divergence_local,&divergence_global,1,MPI_UNSIGNED,MPI_SUM,k,MPI_COMM_WORLD);
		
		// send from local
		if (node_rank==k){
			// left
			if (side_flag[0]){
				for (j=0; j<=PARTITION_HEIGHT; j++){
					buffer_send_left[j]= element_local[j][1];
					}
				MPI_Send(buffer_send_left,PARTITION_HEIGHT,MPI_DOUBLE,0,100*k+0,MPI_COMM_WORLD);
				}
			// top
			if (side_flag[1]){
				memcpy(buffer_send_top, &(element_local[1][1]), sizeof(double)*PARTITION_WIDTH);
				MPI_Send(buffer_send_top,PARTITION_WIDTH,MPI_DOUBLE,0,100*k+1,MPI_COMM_WORLD);
				}
			// right
			if (side_flag[2]){
				for (j=0; j<=PARTITION_HEIGHT; j++){
					buffer_send_right[j]= element_local[j][PARTITION_WIDTH];
					}
				MPI_Send(buffer_send_right,PARTITION_HEIGHT,MPI_DOUBLE,0,100*k+2,MPI_COMM_WORLD);
				}
			// bottom
			if (side_flag[3]){
				memcpy(buffer_send_bottom, &(element_local[PARTITION_HEIGHT][1]), sizeof(double)*PARTITION_WIDTH);
				MPI_Send(buffer_send_bottom,PARTITION_WIDTH,MPI_DOUBLE,0,100*k+3,MPI_COMM_WORLD);
				}
				
			}
		// recv on global
		if (node_rank==0){
			// assign left edge
			if (!(k%NUM_WIDTH==0)){
				MPI_Recv(buffer_recv_left,PARTITION_HEIGHT,MPI_DOUBLE,k,100*k+0,MPI_COMM_WORLD,&status);
				for (j=0; j<PARTITION_HEIGHT; j++){
					element_global[k/NUM_WIDTH*PARTITION_HEIGHT+1+j][k%NUM_WIDTH*PARTITION_WIDTH+1]= buffer_recv_left[j];
					}
				}
			// assign top edge
			if (!(k<NUM_WIDTH)){
				MPI_Recv(buffer_recv_top,PARTITION_WIDTH,MPI_DOUBLE,k,100*k+1,MPI_COMM_WORLD,&status);
				memcpy(&(element_global[k/NUM_WIDTH*PARTITION_HEIGHT+1][k%NUM_WIDTH*PARTITION_WIDTH+1]),buffer_recv_top,sizeof(double)*PARTITION_WIDTH);
				}
			// assign right edge
			if (!(k%NUM_WIDTH==NUM_WIDTH-1)){
				MPI_Recv(buffer_recv_right,PARTITION_HEIGHT,MPI_DOUBLE,k,100*k+2,MPI_COMM_WORLD,&status);
				for (j=0; j<PARTITION_HEIGHT; j++){
					element_global[k/NUM_WIDTH*PARTITION_HEIGHT+1+j][(k%NUM_WIDTH+1)*PARTITION_WIDTH]= buffer_recv_right[j];
					}
				}
			// assign bot edge
			if (!(k>=NUM_WIDTH*(NUM_HEIGHT-1))){
				MPI_Recv(buffer_recv_bottom,PARTITION_WIDTH,MPI_DOUBLE,k,100*k+3,MPI_COMM_WORLD,&status);
				memcpy(&(element_global[(k/NUM_WIDTH+1)*PARTITION_HEIGHT][k%NUM_WIDTH*PARTITION_WIDTH+1]),buffer_recv_bottom,sizeof(double)*PARTITION_WIDTH);
				}
			}	
		}
		
	// aggregation on global
	gettimeofday(&aggregate_start_time,NULL);
	if (node_rank==0){
		for (j=2; j<NUM_HEIGHT*PARTITION_HEIGHT; j++){
		for (i=2; i<NUM_WIDTH*PARTITION_WIDTH; i++){
			temp = 0.25*(element_global[j-1][i]+element_global[j+1][i]+\
						 element_global[j][i-1]+element_global[j][i+1]);
				if (fabs(element_global[j][i]-temp)>ERROR_MARGIN){
					divergence_global=1;
					element_global[j][i]=temp;
					}
				}
			}
		}
	gettimeofday(&aggregate_stop_time,NULL);
	total_aggregation_time += (aggregate_stop_time.tv_sec-aggregate_start_time.tv_sec+\
		(double)(aggregate_stop_time.tv_usec-aggregate_start_time.tv_usec)/1000000);
	
	}


// finish, outputs
printf("bagiempat: node[%d]: computing time= %.6f sec\n",node_rank,total_processing_time);

if (node_rank==0){
	gettimeofday(&stop_time,NULL);
	printf("bagiempat: total steps= %d\n",step);
	//printf("bagiempat: finish= %d.%d\n",stop_time.tv_sec,stop_time.tv_usec);
	printf("bagiempat: total aggregation time= %.6f sec\n",total_aggregation_time);
	printf("bagiempat: elapsed= %.6f sec\n",stop_time.tv_sec-start_time.tv_sec+\
		(double)(stop_time.tv_usec-start_time.tv_usec)/1000000);
		
		//~ for (j=0; j<PARTITION_HEIGHT; j++){
		//~ for (i=0; i<PARTITION_WIDTH*2; i++){
			//~ printf("%f\t",element_global[j][i]);
			//~ }
			//~ printf("\n");
		//~ }
	}

MPI_Finalize();
return(0);
}

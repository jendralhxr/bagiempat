#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/time.h>
#include <mpi.h>
#include <math.h>

// generated by gui apps
#define PARTITION_WIDTH 20
#define PARTITION_HEIGHT 20
#define NUM_WIDTH 4
#define NUM_HEIGHT 3
#define BOUNDARY_LEFT 10
#define BOUNDARY_RIGHT -10
#define BOUNDARY_TOP 30
#define BOUNDARY_BOTTOM 20
#define ERROR_MARGIN 1e-9
#define STEP_MAX 1e3

double **element_local_new, **element_local_old; // a partition
double **element_final; // the whole array, kept at node_rank==0
double *buffer_recv, *buffer_send; // line buffer
unsigned int step=0, divergence_local=1, divergence_final=1;
int node_count, node_rank, node_namelen;
char node_name[MPI_MAX_PROCESSOR_NAME];
struct timeval start_time, stop_time;
int i, j, k, i_min, i_max, j_min, j_max;
MPI_Status status;

int main(int argc, char *argv[]){
	buffer_recv = malloc(sizeof(double)*(PARTITION_WIDTH+2));
	buffer_send = malloc(sizeof(double)*(PARTITION_WIDTH+2));
	
	element_local_old = malloc(sizeof(double*)*(PARTITION_HEIGHT+2));
	element_local_new = malloc(sizeof(double*)*(PARTITION_HEIGHT+2));
	for (i=0; i<PARTITION_HEIGHT+2; i++){
		element_local_old[i] = malloc(sizeof(double)*(PARTITION_WIDTH+2));
		element_local_new[i] = malloc(sizeof(double)*(PARTITION_WIDTH+2));
		}
	
	element_final = malloc(sizeof(double*)*PARTITION_HEIGHT*NUM_HEIGHT);
	for (i=0; i<PARTITION_HEIGHT*NUM_HEIGHT; i++){
		element_final[i] = malloc(sizeof(double)*PARTITION_WIDTH*NUM_WIDTH);
		}
	
	// assigning boundary values
	for (i=0; i<PARTITION_HEIGHT*NUM_HEIGHT; i++){
		element_final[i][0] = BOUNDARY_LEFT;
		element_final[i][PARTITION_WIDTH*NUM_WIDTH-1] = BOUNDARY_RIGHT;
		}
	for (i=0; i<PARTITION_WIDTH*NUM_WIDTH; i++){
		element_final[0][i] = BOUNDARY_TOP;
		element_final[PARTITION_HEIGHT*NUM_HEIGHT-1][i] = BOUNDARY_BOTTOM;
		}
	
	MPI_Init(&argc, &argv);
	MPI_Comm_size(MPI_COMM_WORLD, &node_count);
	MPI_Comm_rank(MPI_COMM_WORLD, &node_rank);
	MPI_Get_processor_name(node_name, &node_namelen);

// start 
if (!node_rank){
	gettimeofday(&start_time,NULL);
	printf("bagiempat: start = %d.%d\n",start_time.tv_sec,start_time.tv_usec);
	}

// do the actual work here
while(divergence_final || (step<STEP_MAX)){
	divergence_final=0;
	// assigment to element_local_old from master node
	for (k=0; k<node_count; k++){
		for (j=0; j<PARTITION_HEIGHT+2; j++){
			if (node_rank==0){
				// top-left corner
				if (k==0){
					for (i=0; i<PARTITION_WIDTH+2; i++){
						if ((j==0) || (i==0)) buffer_send[i]=0;
						else buffer_send[i]=element_final[j-1][i-1];
						}
					}
				// top-right corner
				else if (k==NUM_WIDTH-1){
					for (i=0; i<PARTITION_WIDTH+2; i++){
						if ((j==0) || (i==PARTITION_WIDTH+1)) buffer_send[i]=0;
						else buffer_send[i]=element_final[j-1][PARTITION_WIDTH*(NUM_WIDTH-1)+i-1];
						}
					}
				// bottom-left corner
				else if (k==NUM_HEIGHT*NUM_WIDTH-NUM_WIDTH){
					for (i=0; i<PARTITION_WIDTH+2; i++){
						if ((j==PARTITION_HEIGHT+1) || (i==0)) buffer_send[i]=0;
						else buffer_send[i]=element_final[PARTITION_HEIGHT*(NUM_HEIGHT-1)+j-1][i-1];
						}
					}
				// bottom-right corner
				else if (k==NUM_HEIGHT*NUM_WIDTH-1){
					for (i=0; i<PARTITION_WIDTH+2; i++){
						if ((j==PARTITION_HEIGHT+1) || (i==PARTITION_WIDTH+1)) buffer_send[i]=0;
						else buffer_send[i]=\
							element_final[PARTITION_HEIGHT*(NUM_HEIGHT-1)+j-1][PARTITION_WIDTH*(NUM_WIDTH-1)+i-1];
						}
					}
				// top edges
				else if (k<NUM_WIDTH){
					for (i=0; i<PARTITION_WIDTH+2; i++){
						if (j==0) buffer_send[i]=0;
						else buffer_send[i]=element_final[j-1][PARTITION_WIDTH*k+i-1];
						}
					}
				// bottom edges
				else if (k>=NUM_WIDTH*(NUM_HEIGHT-1)){
					for (i=0; i<PARTITION_WIDTH+2; i++){
						if (j==PARTITION_HEIGHT+1) buffer_send[i]=0;
						else buffer_send[i]=\
							element_final[PARTITION_HEIGHT*(NUM_HEIGHT-1)+j-1][PARTITION_WIDTH*(k%NUM_WIDTH)+i-1];
						}
					}
				// left edges
				else if (k%NUM_WIDTH==0){
					for (i=0; i<PARTITION_WIDTH+2; i++){
						if (i==0) buffer_send[i]=0;
						else buffer_send[i]=element_final[PARTITION_HEIGHT*(k/NUM_HEIGHT)+j-1][i-1];
						}
					}
				// right edges
				else if (k%NUM_WIDTH==NUM_WIDTH-1){
					for (i=0; i<PARTITION_WIDTH+2; i++){
						if (i==PARTITION_WIDTH+1) buffer_send[i]=0;
						else buffer_send[i]=\
							element_final[PARTITION_HEIGHT*(k/NUM_HEIGHT)+j-1][PARTITION_WIDTH*(NUM_WIDTH-1)+i-1];
						}
					}
				// middle partitions
				else{
					for (i=0; i<PARTITION_WIDTH+2; i++){
						buffer_send[i]=element_final[PARTITION_HEIGHT*(k/NUM_HEIGHT)+j-1][PARTITION_WIDTH*(k%NUM_WIDTH)+i-1];
						}
					}
				MPI_Send(buffer_send,PARTITION_WIDTH+2,MPI_DOUBLE,k,0,MPI_COMM_WORLD);
				}
			MPI_Recv(buffer_recv,PARTITION_WIDTH+2,MPI_DOUBLE,0,MPI_ANY_TAG,MPI_COMM_WORLD,&status);
			memcpy(element_local_old[j],buffer_recv,sizeof(double)*(PARTITION_WIDTH+2));
			}
		}	
			
	// boundary check
	// top-left corner
	if (node_rank==0){
		j_min=2; j_max=PARTITION_HEIGHT;
		i_min=2; i_max=PARTITION_WIDTH;
		}
	// top-right corner
	else if (node_rank==NUM_WIDTH-1){
		j_min=2; j_max=PARTITION_HEIGHT;
		i_min=1; i_max=PARTITION_WIDTH-1;
		}
	// bottom-left corner
	else if (node_rank==NUM_HEIGHT*NUM_WIDTH-NUM_WIDTH){
		j_min=1; j_max=PARTITION_HEIGHT-1;
		i_min=2; i_max=PARTITION_WIDTH;
		}
	// bottom-right corner
	else if (node_rank==NUM_HEIGHT*NUM_WIDTH-1){
		j_min=1; j_max=PARTITION_HEIGHT-1;
		i_min=1; i_max=PARTITION_WIDTH-1;
		}
	// top edges
	else if (node_rank<NUM_WIDTH){
		j_min=2; j_max=PARTITION_HEIGHT;
		i_min=1; i_max=PARTITION_WIDTH;
		}
	// bottom edges
	else if (node_rank>=NUM_WIDTH*(NUM_HEIGHT-1)){
		j_min=1; j_max=PARTITION_HEIGHT-1;
		i_min=1; i_max=PARTITION_WIDTH;
		}
	// left edges
	else if (node_rank%NUM_WIDTH==0){
		j_min=1; j_max=PARTITION_HEIGHT;
		i_min=2; i_max=PARTITION_WIDTH;
		}
	// right edges
	else if (node_rank%NUM_WIDTH==NUM_WIDTH-1){
		j_min=1; j_max=PARTITION_HEIGHT;
		i_min=1; i_max=PARTITION_WIDTH-1;
		}
	// middle partitions
	else{
		j_min=1; j_max=PARTITION_HEIGHT;
		i_min=1; i_max=PARTITION_WIDTH;
		}

	// computing element_local_new: 4-way mean for elements within each partition
	// divergence check
	divergence_local=0;
	for (j=j_min; j<=j_max; j++){
		for (i=i_min; i<=i_max; i++){
			element_local_new[j][i] = 0.25 *\
				(element_local_old[j-1][i]+element_local_old[j+1][i]+\
				element_local_old[j][i-1]+element_local_old[j][i+1]);
				if (fabs(element_local_old[j][i]-element_local_new[j][i])>ERROR_MARGIN) divergence_local=1;
			}
		}
		
	// summing divergence values
	for (k=0; k<node_count; k++){
		MPI_Reduce(&divergence_local,&divergence_final,1,MPI_UNSIGNED,MPI_SUM,k,MPI_COMM_WORLD);
		}
	
	// update to element_final
	for (k=0; k<node_count; k++){
		for (j=0; j<PARTITION_HEIGHT; j++){
			// send
			if (node_rank==k){
				memcpy(buffer_send,&(element_local_new[j+1][1]),sizeof(double)*PARTITION_WIDTH);
				MPI_Send(buffer_send,PARTITION_WIDTH,MPI_DOUBLE,k,0,MPI_COMM_WORLD);
				}
			// recv
			if (node_rank==0){
				MPI_Recv(buffer_recv,PARTITION_WIDTH,MPI_DOUBLE,0,MPI_ANY_TAG,MPI_COMM_WORLD,&status);
				memcpy(&(element_final[k/NUM_HEIGHT*PARTITION_HEIGHT+j][k%NUM_WIDTH*PARTITION_WIDTH]),\
					buffer_recv,sizeof(double)*PARTITION_WIDTH);
				}	
			}
		}
	}
	
// finish, outputs
if (!node_rank){
	gettimeofday(&stop_time,NULL);
	printf("bagiempat: finish = %d.%d\n",stop_time.tv_sec,stop_time.tv_usec);
	printf("bagiempat: elapsed = %f sec\n",stop_time.tv_sec-start_time.tv_sec+\
		(double)(stop_time.tv_usec-start_time.tv_usec)/1000000);
	foo:
	for(j=0; j>PARTITION_HEIGHT*NUM_HEIGHT; j++){
		for(i=0; i<PARTITION_WIDTH*NUM_WIDTH; i++){
			printf("%.6f;",element_final[j][i]);
			}
		printf("\n");
		}	
	}

MPI_Finalize();
return(0);
}

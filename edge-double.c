#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/time.h>
#include <mpi.h>
#include <math.h>

// generated by gui apps
#define PARTITION_WIDTH 3
#define PARTITION_HEIGHT 6
#define BOUNDARY_LEFT 10
#define BOUNDARY_RIGHT -10
#define BOUNDARY_TOP 30
#define BOUNDARY_BOTTOM 200
#define ERROR_MARGIN 1e-9
#define STEP_MAX 1e6

double **element_local, **element_global, temp; // the whole array, kept at node_rank==0
double *buffer_recv, *buffer_send; // line buffer
unsigned int step=0, divergence_local=1, divergence_global=1;
int node_count, node_rank, node_namelen;
char node_name[MPI_MAX_PROCESSOR_NAME];
struct timeval start_time, stop_time;
struct timeval process_start_time, process_stop_time;
struct timeval aggregate_start_time, aggregate_stop_time;
double total_processing_time, total_aggregation_time; // sec
int i, j, k;
MPI_Status status;

int main(int argc, char *argv[]){
	buffer_recv = malloc(sizeof(double)*(PARTITION_HEIGHT));
	buffer_send = malloc(sizeof(double)*(PARTITION_HEIGHT));
	
	element_local = malloc(sizeof(double*)*(PARTITION_HEIGHT));
	for (j=0; j<PARTITION_HEIGHT; j++){
		element_local[j] = malloc(sizeof(double)*(PARTITION_WIDTH));
		}
	
	element_global = malloc(sizeof(double*)*PARTITION_HEIGHT);
	for (j=0; j<PARTITION_HEIGHT; j++){
		element_global[j] = malloc(sizeof(double)*PARTITION_WIDTH*2);
		}
	
	MPI_Init(&argc, &argv);
	MPI_Comm_size(MPI_COMM_WORLD, &node_count);
	MPI_Comm_rank(MPI_COMM_WORLD, &node_rank);
	MPI_Get_processor_name(node_name, &node_namelen);

// assigning global boundary values
	for (j=0; j<PARTITION_HEIGHT; j++){
		element_global[j][0] = BOUNDARY_LEFT;
		element_global[j][2*PARTITION_WIDTH-1] = BOUNDARY_RIGHT;
		}
	for (i=0; i<PARTITION_WIDTH*2; i++){
		element_global[0][i] = BOUNDARY_TOP;
		element_global[PARTITION_HEIGHT-1][i] = BOUNDARY_BOTTOM;
		}

// assigning local boundary values
switch(node_rank){
	//left section
	case 0:
		for (i=0; i<PARTITION_WIDTH; i++){
			element_local[0][i]= BOUNDARY_TOP;
			element_local[PARTITION_HEIGHT-1][i]= BOUNDARY_BOTTOM;
			}
		for (j=0; j<PARTITION_HEIGHT; j++){
			element_local[j][0]= BOUNDARY_LEFT;
			}	
	break;
	//right section
	case 1:
	for (i=0; i<PARTITION_WIDTH; i++){
		element_local[0][i]= BOUNDARY_TOP;
		element_local[PARTITION_HEIGHT-1][i]= BOUNDARY_BOTTOM;
		}
	for (j=0; j<PARTITION_HEIGHT; j++){
		element_local[j][PARTITION_WIDTH-1]= BOUNDARY_RIGHT;
		}
	break;
	default:
	break;
	}
		
// global start time 
if (!node_rank){
	gettimeofday(&start_time,NULL);
	//printf("bagiempat: start = %d.%d\n",start_time.tv_sec,start_time.tv_usec);
	}

// do the actual work here
while(divergence_global && (step<STEP_MAX)){
	step++;
	divergence_global=0;
	
	// assigment to element_local from master node
	for (k=0; k<=1; k++){
		if (node_rank==0){
			for (j=0; j<PARTITION_HEIGHT; j++){
				buffer_send[j]= element_global[j][PARTITION_WIDTH-1+k];
				}
			// sending to local workers	
			MPI_Send(buffer_send,PARTITION_HEIGHT,MPI_DOUBLE,k,1,MPI_COMM_WORLD);
			}
			
		if (node_rank==k){
			MPI_Recv(buffer_recv,PARTITION_HEIGHT,MPI_DOUBLE,0,1,MPI_COMM_WORLD,&status);
			// left section
			if (k==0){
				for (j=0; j<PARTITION_HEIGHT; j++){
					element_local[j][PARTITION_WIDTH]= buffer_recv[j];
					}
				}
			// right section
			else if (k==1){
				for (j=0; j<PARTITION_HEIGHT; j++){
					element_local[j][0]= buffer_recv[j];
					}
				}
			}
		}
											
	// computing element_local: 4-way mean for elements within each partition
	// divergence check
	gettimeofday(&process_start_time,NULL);	
	divergence_local=0;
	for (j=1; j<PARTITION_HEIGHT-1; j++){
		for (i=1; i<PARTITION_WIDTH-1; i++){
			temp = 0.25*(element_local[j-1][i]+element_local[j+1][i]+\
						 element_local[j][i-1]+element_local[j][i+1]);
			if (fabs(element_local[j][i]-temp)>ERROR_MARGIN){
				divergence_local=1;
				element_local[j][i]=temp;
				}
			}
		}
		
	gettimeofday(&process_stop_time,NULL);
	total_processing_time += (process_stop_time.tv_sec-process_start_time.tv_sec+\
		(double)(process_stop_time.tv_usec-process_start_time.tv_usec)/1000000);
	
	// summing divergence values
	for (k=0; k<node_count; k++){
		//if (node_rank==k)
		MPI_Reduce(&divergence_local,&divergence_global,1,MPI_UNSIGNED,MPI_SUM,k,MPI_COMM_WORLD);
		}
	
	// update to element_global
	for (k=0; k<node_count; k++){
		// send
		if (node_rank==k){
			// left section
			if (node_rank==0){
				for (j=0; j<PARTITION_HEIGHT; j++){
					buffer_send[j]= element_local[j][PARTITION_WIDTH];
					}
				}
			// right section
			else if (node_rank==1){
				for (j=0; j<PARTITION_HEIGHT; j++){
					buffer_send[j]= element_local[j][0];
					}
				}			
			MPI_Send(buffer_send,PARTITION_HEIGHT,MPI_DOUBLE,0,2,MPI_COMM_WORLD);
			}
				
		// recv
		if (node_rank==0){
			MPI_Recv(buffer_recv,PARTITION_HEIGHT,MPI_DOUBLE,k,2,MPI_COMM_WORLD,&status);
			for (j=0; j<PARTITION_HEIGHT; j++){
				element_global[j][PARTITION_WIDTH-1+k]= buffer_recv[j];
				}
			
			//aggregation
			gettimeofday(&aggregate_start_time,NULL);
			for (j=0; j<PARTITION_HEIGHT; j++){
				temp= 0.5*(element_global[j][PARTITION_WIDTH-1]+element_global[j][PARTITION_WIDTH]);
				element_global[j][PARTITION_WIDTH-1]= temp;
				element_global[j][PARTITION_WIDTH]= temp;
				}
			}
			
			// 4-way mean on global element
			for (j=1; j<PARTITION_HEIGHT-1; j++){
				for (i=1; i<PARTITION_WIDTH*2-1; i++){
					temp = 0.25*(element_global[j-1][i]+element_global[j+1][i]+\
						 element_global[j][i-1]+element_global[j][i+1]);
					if (fabs(element_global[j][i]-temp)>ERROR_MARGIN){
						divergence_local=1;
						element_global[j][i]=temp;
					}
				}
			}
						
			gettimeofday(&aggregate_stop_time,NULL);
			total_aggregation_time += (aggregate_stop_time.tv_sec-aggregate_start_time.tv_sec+\
				(double)(aggregate_stop_time.tv_usec-aggregate_start_time.tv_usec)/1000000);
				
		}
	}
	
// finish, outputs
printf("bagiempat: node[%d]: computing time= %.6f sec\n",node_rank,total_processing_time);

if (node_rank==0){
	gettimeofday(&stop_time,NULL);
	printf("bagiempat: total steps= %d\n",step);
	//printf("bagiempat: finish = %d.%d\n",stop_time.tv_sec,stop_time.tv_usec);
	printf("bagiempat: aggregation time= %.6f\n",total_aggregation_time);
	printf("bagiempat: elapsed= %.6f sec\n",stop_time.tv_sec-start_time.tv_sec+\
		(double)(stop_time.tv_usec-start_time.tv_usec)/1000000);
	
	//~ for (j=0; j<PARTITION_HEIGHT; j++){
		//~ for (i=0; i<PARTITION_WIDTH*2; i++){
			//~ printf("%f\t",element_global[j][i]);
			//~ }
			//~ printf("\n");
		//~ }
	}

	
MPI_Finalize();
return(0);
}

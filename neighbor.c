#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/time.h>
#include <mpi.h>
#include <math.h>

// generated by gui apps
#define PARTITION_WIDTH 4
#define PARTITION_HEIGHT 4
#define NUM_WIDTH 2
#define NUM_HEIGHT 2
#define BOUNDARY_LEFT 10
#define BOUNDARY_RIGHT -10
#define BOUNDARY_TOP 30
#define BOUNDARY_BOTTOM 200
#define ERROR_MARGIN 1e-9
#define STEP_MAX 1e6

double **element_local, **element_global, temp; // the whole array, kept at node_rank==0
double *buffer_recv_top, *buffer_recv_bottom, *buffer_recv_left, *buffer_recv_right;
double *buffer_send_top, *buffer_send_bottom, *buffer_send_left, *buffer_send_right;
unsigned int step=0, divergence_local=1, divergence_global=1;
int node_count, node_rank, node_namelen;
char node_name[MPI_MAX_PROCESSOR_NAME];
struct timeval start_time, stop_time;
struct timeval process_start_time, process_stop_time;
double total_processing_time; // sec
char side_flag[4]; // 0, 1, 2, 3: left, top, right, bot
int i, j, k, i_min, i_max, j_min, j_max;
MPI_Status status;

int main(int argc, char *argv[]){
	buffer_recv_top = malloc(sizeof(double)*(PARTITION_WIDTH+2));
	buffer_recv_bottom = malloc(sizeof(double)*(PARTITION_WIDTH+2));
	buffer_recv_left = malloc(sizeof(double)*(PARTITION_HEIGHT+2));
	buffer_recv_right = malloc(sizeof(double)*(PARTITION_HEIGHT+2));
	buffer_send_top = malloc(sizeof(double)*(PARTITION_WIDTH+2));
	buffer_send_bottom = malloc(sizeof(double)*(PARTITION_WIDTH+2));
	buffer_send_left = malloc(sizeof(double)*(PARTITION_HEIGHT+2));
	buffer_send_right = malloc(sizeof(double)*(PARTITION_HEIGHT+2));
	
	element_local = malloc(sizeof(double*)*(PARTITION_HEIGHT+2));
	for (i=0; i<PARTITION_HEIGHT; i++){
		element_local[i] = malloc(sizeof(double)*(PARTITION_WIDTH+2));
		}
	
	element_global = malloc(sizeof(double*)*(PARTITION_HEIGHT*NUM_HEIGHT));
	for (i=0; i<PARTITION_HEIGHT*NUM_HEIGHT; i++){
		element_global[i] = malloc(sizeof(double)*(PARTITION_WIDTH*NUM_WIDTH));
		}
	
	MPI_Init(&argc, &argv);
	MPI_Comm_size(MPI_COMM_WORLD, &node_count);
	MPI_Comm_rank(MPI_COMM_WORLD, &node_rank);
	MPI_Get_processor_name(node_name, &node_namelen);

	// 0: don't mess; 1: you may do so
	side_flag[0]=(node_rank%NUM_WIDTH==0)?0:1;
	side_flag[1]=(node_rank<NUM_WIDTH)?0:1;
	side_flag[2]=(node_rank%NUM_WIDTH==NUM_WIDTH-1)?0:1;
	side_flag[3]=(node_rank>=NUM_WIDTH*(NUM_HEIGHT-1))?0:1;

	// local assigment is necessary here
	// assign left boundary
	if (node_rank%NUM_WIDTH==0){
		for (j=0; j<PARTITION_HEIGHT+2; j++){
			element_local[j][1]= BOUNDARY_LEFT;	
			}
		}
	// assign top boundary
	if (node_rank<NUM_WIDTH){
		for (i=0; i<PARTITION_WIDTH+2; i++){
			element_local[1][i]= BOUNDARY_TOP;
			}
		}
	// assign right boundary
	if (node_rank%NUM_WIDTH==NUM_WIDTH-1){
		for (j=0; j<PARTITION_HEIGHT+2; j++){
			element_local[j][PARTITION_WIDTH]= BOUNDARY_RIGHT;	
			}
		}
	// assign bot boundary
	if (node_rank>=NUM_WIDTH*(NUM_HEIGHT-1)){
		for (i=0; i<PARTITION_WIDTH+2; i++){
			element_local[PARTITION_HEIGHT][i]= BOUNDARY_BOTTOM;
			}
		}
	
// start
if (!node_rank){
	gettimeofday(&start_time,NULL);
	//printf("bagiempat: start = %d.%d\n",start_time.tv_sec,start_time.tv_usec);
	}

// do the actual work here
while(divergence_global && (step<STEP_MAX)){
	step++;
	divergence_global=0;
	// exchange elements from neighboring nodes
	// tag is sender_rank*100 + side_id
	// assign left edge
	if (side_flag[0]){
		// send local left edge
		for (j=0; j<PARTITION_HEIGHT+2; j++){
			buffer_send_left[j]= element_local[j][1];
			}
		MPI_Send(buffer_send_left,PARTITION_HEIGHT+2,MPI_DOUBLE,node_rank-1,100*node_rank+0,MPI_COMM_WORLD);	
		// get left neighbor right edge			
		MPI_Recv(buffer_recv_left,PARTITION_HEIGHT+2,MPI_DOUBLE,node_rank-1,100*(node_rank-1)+2,MPI_COMM_WORLD,&status);
		for (j=0; j<PARTITION_HEIGHT+2; j++){
			element_local[j][0]= buffer_recv_left[j];
			}
		}
	// assign top edge
	if (side_flag[1]){
		// send local top edge
		memcpy(buffer_send_top,element_local[1],sizeof(double)*(PARTITION_WIDTH+2));
		MPI_Send(buffer_send_top,PARTITION_WIDTH+2,MPI_DOUBLE,node_rank-PARTITION_WIDTH,100*node_rank+1,MPI_COMM_WORLD);
		// recv top neighbor bottom edge
		MPI_Recv(buffer_recv_top,PARTITION_WIDTH+2,MPI_DOUBLE,node_rank-PARTITION_WIDTH,100*(node_rank-PARTITION_WIDTH)+3,MPI_COMM_WORLD,&status);
		memcpy(element_local[0],buffer_recv_top,sizeof(double)*PARTITION_WIDTH+2);
		}
	// assign right edge
	if (side_flag[2]){
		// send local right edge
		for (j=0; j<PARTITION_HEIGHT+2; j++){
			buffer_send_right[j]= element_local[j][PARTITION_WIDTH];
			}
		MPI_Send(buffer_send_right,PARTITION_HEIGHT+2,MPI_DOUBLE,node_rank+1,100*node_rank+2,MPI_COMM_WORLD);
		// recv right neighbor left edge 
		MPI_Recv(buffer_recv_right,PARTITION_HEIGHT+2,MPI_DOUBLE,node_rank+1,100*(node_rank+1)+0,MPI_COMM_WORLD,&status);
			for (j=0; j<PARTITION_HEIGHT+2; j++){
				element_local[j][PARTITION_WIDTH+1]= buffer_recv_right[j];
			}
		}
	// assign bot edge
	if (side_flag[3]){
		// send local bottom edge
		memcpy(buffer_send_bottom,element_local[PARTITION_HEIGHT+1],sizeof(double)*(PARTITION_WIDTH+2));
		MPI_Send(buffer_send_bottom,PARTITION_WIDTH+2,MPI_DOUBLE,node_rank+PARTITION_WIDTH,100*node_rank+3,MPI_COMM_WORLD);
		// recv bottom neighbor top edge
		MPI_Recv(buffer_recv_bottom,PARTITION_HEIGHT+2,MPI_DOUBLE,node_rank-PARTITION_WIDTH,100*(node_rank-PARTITION_WIDTH)+1,MPI_COMM_WORLD,&status);
		memcpy(element_local[PARTITION_WIDTH+1],buffer_recv_bottom,sizeof(double)*PARTITION_WIDTH+2);
		}
					
	// processing boundary check
	// top-left corner
	if (node_rank==0){
		j_min=2; j_max=PARTITION_HEIGHT;
		i_min=2; i_max=PARTITION_WIDTH;
		}
	// top-right corner
	else if (node_rank==NUM_WIDTH-1){
		j_min=2; j_max=PARTITION_HEIGHT;
		i_min=1; i_max=PARTITION_WIDTH-1;
		}
	// bottom-left corner
	else if (node_rank==NUM_HEIGHT*NUM_WIDTH-NUM_WIDTH){
		j_min=1; j_max=PARTITION_HEIGHT-1;
		i_min=2; i_max=PARTITION_WIDTH;
		}
	// bottom-right corner
	else if (node_rank==NUM_HEIGHT*NUM_WIDTH-1){
		j_min=1; j_max=PARTITION_HEIGHT-1;
		i_min=1; i_max=PARTITION_WIDTH-1;
		}
	// top edges
	else if (node_rank<NUM_WIDTH){
		j_min=2; j_max=PARTITION_HEIGHT;
		i_min=1; i_max=PARTITION_WIDTH;
		}
	// bottom edges
	else if (node_rank>=NUM_WIDTH*(NUM_HEIGHT-1)){
		j_min=1; j_max=PARTITION_HEIGHT-1;
		i_min=1; i_max=PARTITION_WIDTH;
		}
	// left edges
	else if (node_rank%NUM_WIDTH==0){
		j_min=1; j_max=PARTITION_HEIGHT;
		i_min=2; i_max=PARTITION_WIDTH;
		}
	// right edges
	else if (node_rank%NUM_WIDTH==NUM_WIDTH-1){
		j_min=1; j_max=PARTITION_HEIGHT;
		i_min=1; i_max=PARTITION_WIDTH-1;
		}
	// middle partitions
	else{
		j_min=1; j_max=PARTITION_HEIGHT;
		i_min=1; i_max=PARTITION_WIDTH;
		}

	// computing element_local: 4-way mean for elements within each partition
	// divergence check
	gettimeofday(&process_start_time,NULL);	
	divergence_local=0;
	for (j=j_min; j<=j_max; j++){
		for (i=i_min; i<=i_max; i++){
			temp = 0.25*(element_local[j-1][i]+element_local[j+1][i]+\
						 element_local[j][i-1]+element_local[j][i+1]);
			if (fabs(element_local[j][i]-temp)>ERROR_MARGIN){
				divergence_local=1;
				element_local[j][i]=temp;
				}
			}
		}
	gettimeofday(&process_stop_time,NULL);	
	total_processing_time += (process_stop_time.tv_sec-process_start_time.tv_sec+\
		(double)(process_stop_time.tv_usec-process_start_time.tv_usec)/1000000);
	
	// checking global divergence
	for (k=0; k<node_count; k++){
		// summing divergence values
		MPI_Reduce(&divergence_local,&divergence_global,1,MPI_UNSIGNED,MPI_SUM,k,MPI_COMM_WORLD);
		}
	}

for (k=0; k<node_count; k++){
	for (j=1; j<=PARTITION_HEIGHT; j++){
		// send
		if (node_rank==k){
			memcpy(buffer_send_top,&(element_local[j][1]),sizeof(double)*PARTITION_WIDTH);
			MPI_Send(buffer_send_top,PARTITION_WIDTH,MPI_DOUBLE,0,3,MPI_COMM_WORLD);
			}
		// recv
		if (node_rank==0){
			MPI_Recv(buffer_recv_top,PARTITION_WIDTH,MPI_DOUBLE,k,3,MPI_COMM_WORLD,&status);
			memcpy(&(element_global[k/NUM_WIDTH*PARTITION_HEIGHT+j-1][(k%NUM_WIDTH)*PARTITION_WIDTH]),\
				buffer_recv_top,sizeof(double)*PARTITION_WIDTH);
			}	
		}
	}

// finish, outputs
printf("bagiempat: node[%d]: computing time= %.6f sec\n",node_rank,total_processing_time);

if (node_rank==0){
	gettimeofday(&stop_time,NULL);
	printf("bagiempat: total steps= %d\n",step);
	//printf("bagiempat: finish= %d.%d\n",stop_time.tv_sec,stop_time.tv_usec);
	printf("bagiempat: elapsed= %.6f sec\n",stop_time.tv_sec-start_time.tv_sec+\
		(double)(stop_time.tv_usec-start_time.tv_usec)/1000000);
		
		//~ for (j=0; j<PARTITION_HEIGHT; j++){
		//~ for (i=0; i<PARTITION_WIDTH*2; i++){
			//~ printf("%f\t",element_global[j][i]);
			//~ }
			//~ printf("\n");
		//~ }
	}

MPI_Finalize();
return(0);
}
